package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/Jassem-HCP/nompose/internal/types"
)

// NomadGenerator creates Nomad job files
type NomadGenerator struct {
	outputDir string
}

// NewNomadGenerator creates a new Nomad job generator
func NewNomadGenerator(outputDir string) *NomadGenerator {
	if outputDir == "" {
		outputDir = "."
	}
	return &NomadGenerator{
		outputDir: outputDir,
	}
}

// GenerateJobs creates enhanced Nomad job files for multiple services
func (g *NomadGenerator) GenerateJobs(services []types.EnhancedServiceConfig) error {
	fmt.Printf("ðŸ“ Generating production-ready Nomad job files...\n")

	var generatedFiles []string

	for i, service := range services {
		fmt.Printf("Processing service %d/%d: %s\n", i+1, len(services), service.Name)

		filename, err := g.generateEnhancedJob(service)
		if err != nil {
			return fmt.Errorf("failed to generate job for service %s: %w", service.Name, err)
		}
		generatedFiles = append(generatedFiles, filename)
	}

	// Show comprehensive summary
	fmt.Printf("âœ… Generated %d Nomad job files:\n", len(generatedFiles))
	for i, file := range generatedFiles {
		fmt.Printf("   %d. %s\n", i+1, file)
	}

	fmt.Println("\nðŸš€ Next steps:")
	fmt.Println("   Deploy services:")
	for _, file := range generatedFiles {
		fmt.Printf("   nomad job run %s\n", file)
	}

	return nil
}

// generateEnhancedJob creates an enhanced Nomad job file
func (g *NomadGenerator) generateEnhancedJob(service types.EnhancedServiceConfig) (string, error) {
	// Generate enhanced job content
	jobContent := g.createEnhancedJobContent(service)

	// Create filename with .nomad.hcl extension
	filename := fmt.Sprintf("%s.nomad.hcl", service.Name)
	filepath := filepath.Join(g.outputDir, filename)

	// Write file
	if err := os.WriteFile(filepath, []byte(jobContent), 0644); err != nil {
		return "", fmt.Errorf("failed to write job file: %w", err)
	}

	return filename, nil
}

// createEnhancedJobContent generates enhanced HCL content
func (g *NomadGenerator) createEnhancedJobContent(service types.EnhancedServiceConfig) string {
	var content strings.Builder

	// Job header with metadata
	content.WriteString(fmt.Sprintf(`# Generated by Nompose - Production Ready
# Service: %s
# Image: %s
# Ports: %s
# Environment: %d variables

job "%s" {
  datacenters = ["dc1"]
  type        = "service"

  group "%s" {
    count = %d

`,
		service.Name,
		service.ResolvedImage,
		g.getPortsDescription(service),
		len(service.Environment),
		service.Name,
		service.Name,
		g.getReplicas(service)))

	// Enhanced network configuration with multiple ports
	content.WriteString(g.generateNetworkConfig(service))

	// Task configuration
	content.WriteString(`    task "app" {
      driver = "docker"

      config {
        image = "` + service.ResolvedImage + `"`)

	// Add all ports
	if len(service.ResolvedPorts) > 0 {
		content.WriteString(`
        ports = [` + g.getPortNames(service) + `]`)
	}

	content.WriteString(`
      }

      resources {
        cpu    = ` + fmt.Sprintf("%d", g.getSmartCPU(service)) + `
        memory = ` + fmt.Sprintf("%d", g.getSmartMemory(service)) + `
      }

`)

	// Add environment variables
	if len(service.Environment) > 0 {
		content.WriteString(g.generateEnvironmentConfig(service))
	}

	// Enhanced service registration
	if len(service.ResolvedPorts) > 0 {
		content.WriteString(g.generateServiceConfig(service))
	}

	// Add comments for volumes and dependencies
	if len(service.OriginalService.Volumes) > 0 {
		content.WriteString("      # Volumes detected: " + strings.Join(service.OriginalService.Volumes, ", ") + "\n\n")
	}

	if len(service.Dependencies) > 0 {
		content.WriteString("      # Dependencies: " + strings.Join(service.Dependencies, ", ") + "\n")
		content.WriteString("      # Deploy dependencies first!\n\n")
	}

	// Close task and group
	content.WriteString(`    }
  }
}`)

	return content.String()
}

// generateNetworkConfig creates network configuration with multiple ports
func (g *NomadGenerator) generateNetworkConfig(service types.EnhancedServiceConfig) string {
	if len(service.ResolvedPorts) == 0 {
		return ""
	}

	var config strings.Builder
	config.WriteString("    network {\n")

	// Add all detected ports
	for i, port := range service.ResolvedPorts {
		portName := "http"
		if i > 0 {
			portName = fmt.Sprintf("port_%d", port.Host)
		}

		config.WriteString(fmt.Sprintf(`      port "%s" {
        static = %d
      }
`, portName, port.Host))
	}

	config.WriteString("    }\n\n")
	return config.String()
}

// generateEnvironmentConfig creates environment variables
func (g *NomadGenerator) generateEnvironmentConfig(service types.EnhancedServiceConfig) string {
	var config strings.Builder

	config.WriteString("      env {\n")
	for key, value := range service.Environment {
		// Escape quotes in values
		escapedValue := strings.ReplaceAll(value, `"`, `\"`)
		config.WriteString(fmt.Sprintf(`        %s = "%s"
`, key, escapedValue))
	}
	config.WriteString("      }\n\n")

	return config.String()
}

// generateServiceConfig creates service registration
func (g *NomadGenerator) generateServiceConfig(service types.EnhancedServiceConfig) string {
	return fmt.Sprintf(`      service {
        name = "%s"
        port = "http"
        tags = ["docker", "%s", "nompose"]

        check {
          type     = "tcp"
          interval = "30s"
          timeout  = "3s"
          port     = "http"
        }
      }

`, service.Name, service.Name)
}

// Helper functions
func (g *NomadGenerator) getReplicas(service types.EnhancedServiceConfig) int {
	if service.OriginalService.Deploy != nil && service.OriginalService.Deploy.Replicas > 0 {
		return service.OriginalService.Deploy.Replicas
	}
	return 1
}

func (g *NomadGenerator) getSmartCPU(service types.EnhancedServiceConfig) int {
	serviceName := strings.ToLower(service.Name)
	switch {
	case strings.Contains(serviceName, "db") || strings.Contains(serviceName, "database"):
		return 1000
	case strings.Contains(serviceName, "cache") || strings.Contains(serviceName, "redis"):
		return 300
	case strings.Contains(serviceName, "frontend") || strings.Contains(serviceName, "web"):
		return 300
	case strings.Contains(serviceName, "api") || strings.Contains(serviceName, "backend"):
		return 800
	default:
		return 500
	}
}

func (g *NomadGenerator) getSmartMemory(service types.EnhancedServiceConfig) int {
	serviceName := strings.ToLower(service.Name)
	switch {
	case strings.Contains(serviceName, "db") || strings.Contains(serviceName, "database"):
		return 1024
	case strings.Contains(serviceName, "cache") || strings.Contains(serviceName, "redis"):
		return 256
	default:
		return 512
	}
}

func (g *NomadGenerator) getPortsDescription(service types.EnhancedServiceConfig) string {
	if len(service.ResolvedPorts) == 0 {
		return "none"
	}

	var ports []string
	for _, port := range service.ResolvedPorts {
		ports = append(ports, fmt.Sprintf("%d", port.Host))
	}
	return strings.Join(ports, ", ")
}

func (g *NomadGenerator) getPortNames(service types.EnhancedServiceConfig) string {
	if len(service.ResolvedPorts) == 0 {
		return ""
	}

	var names []string
	for i := range service.ResolvedPorts {
		if i == 0 {
			names = append(names, `"http"`)
		} else {
			names = append(names, fmt.Sprintf(`"port_%d"`, service.ResolvedPorts[i].Host))
		}
	}
	return strings.Join(names, ", ")
}
