package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/Jassem-HCP/nompose/internal/types"
)

// NomadGenerator creates Nomad job files from service configurations
type NomadGenerator struct {
	outputDir string
}

// NewNomadGenerator creates a new Nomad job generator
func NewNomadGenerator(outputDir string) *NomadGenerator {
	if outputDir == "" {
		outputDir = "."
	}
	return &NomadGenerator{
		outputDir: outputDir,
	}
}

// GenerateJobs creates Nomad job files for multiple services
func (g *NomadGenerator) GenerateJobs(services []types.ServiceConfig) error {
	fmt.Printf("ðŸ“ Generating Nomad job files...\n")

	var generatedFiles []string

	for _, service := range services {
		filename, err := g.generateSingleJob(service)
		if err != nil {
			return fmt.Errorf("failed to generate job for service %s: %w", service.Name, err)
		}
		generatedFiles = append(generatedFiles, filename)
	}

	// Show summary
	fmt.Printf("âœ… Generated %d Nomad job files:\n", len(generatedFiles))
	for i, file := range generatedFiles {
		fmt.Printf("   %d. %s\n", i+1, file)
	}

	fmt.Println("\nðŸš€ Next steps:")
	fmt.Println("   Review the generated files, then deploy with:")
	for _, file := range generatedFiles {
		fmt.Printf("   nomad job run %s\n", file)
	}

	return nil
}

// generateSingleJob creates a single Nomad job file
func (g *NomadGenerator) generateSingleJob(service types.ServiceConfig) (string, error) {
	// Generate job content
	jobContent := g.createJobContent(service)

	// Create filename
	filename := fmt.Sprintf("%s.nomad.hcl", service.Name)
	filepath := filepath.Join(g.outputDir, filename)

	// Write file
	if err := os.WriteFile(filepath, []byte(jobContent), 0644); err != nil {
		return "", fmt.Errorf("failed to write job file: %w", err)
	}

	return filename, nil
}

// createJobContent generates the HCL content for a Nomad job
func (g *NomadGenerator) createJobContent(service types.ServiceConfig) string {
	var content strings.Builder

	// Job header
	content.WriteString(fmt.Sprintf(`# Generated by Nompose
# Service: %s
# Image: %s

job "%s" {
  datacenters = ["dc1"]
  type        = "service"

`, service.Name, service.Image, service.Name))

	// Group configuration
	content.WriteString(fmt.Sprintf(`  group "%s" {
    count = %d

`, service.Name, service.Replicas))

	// Network configuration (if port is specified)
	if service.Port > 0 {
		content.WriteString(fmt.Sprintf(`    network {
      port "http" {
        static = %d
      }
    }

`, service.Port))
	}

	// Task configuration
	content.WriteString(fmt.Sprintf(`    task "app" {
      driver = "docker"

      config {
        image = "%s"`, service.Image))

	// Add ports if specified
	if service.Port > 0 {
		content.WriteString(`
        ports = ["http"]`)
	}

	content.WriteString(`
      }

`)

	// Resources (basic defaults for now)
	content.WriteString(`      resources {
        cpu    = 500
        memory = 512
      }

`)

	// Environment variables
	if len(service.Environment) > 0 {
		content.WriteString(`      env {
`)
		for key, value := range service.Environment {
			// Escape quotes in values
			escapedValue := strings.ReplaceAll(value, `"`, `\"`)
			content.WriteString(fmt.Sprintf(`        %s = "%s"
`, key, escapedValue))
		}
		content.WriteString(`      }

`)
	}

	// Service registration (if port is specified)
	if service.Port > 0 {
		content.WriteString(fmt.Sprintf(`      service {
        name = "%s"
        port = "http"
        tags = ["docker", "%s"]

`, service.Name, service.Name))

		// Health check
		if service.HealthCheck != "" {
			content.WriteString(fmt.Sprintf(`        check {
          type     = "http"
          path     = "%s"
          interval = "30s"
          timeout  = "3s"
          port     = "http"
        }
`, service.HealthCheck))
		}

		content.WriteString(`      }

`)
	}

	// Volumes (basic implementation)
	if len(service.Volumes) > 0 {
		content.WriteString(`      # Volumes detected - manual configuration may be needed:
`)
		for _, volume := range service.Volumes {
			content.WriteString(fmt.Sprintf(`      # %s
`, volume))
		}
		content.WriteString(`

`)
	}

	// Dependencies (as comments for now)
	if len(service.DependsOn) > 0 {
		content.WriteString(`      # Service dependencies detected:
`)
		for _, dep := range service.DependsOn {
			content.WriteString(fmt.Sprintf(`      # Depends on: %s
`, dep))
		}
		content.WriteString(`      # Note: Ensure dependent services are deployed first

`)
	}

	// Close task and group
	content.WriteString(`    }
  }
}`)

	return content.String()
}
